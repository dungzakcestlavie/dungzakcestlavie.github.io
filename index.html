<!-- ==========================================================
③ SCRIPTS  (FINAL — NO LAYOUT HACK / WORKS ZOOM FIX / REPORTS KR-EN / BIO SYNC / SOUND & WAVES)
========================================================== -->
<script>
(() => {
  "use strict";

  /* -----------------------------
     Helpers
  ----------------------------- */
  const $  = (sel, root=document) => root.querySelector(sel);
  const $$ = (sel, root=document) => Array.from(root.querySelectorAll(sel));

  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));
  const bust = () => (Date.now().toString(36));

  const safeText = (v) => String(v ?? "");
  const esc = (s) => String(s ?? "")
    .replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")
    .replace(/"/g,"&quot;").replace(/'/g,"&#39;");

  const slash = (p) => {
    const s = safeText(p).trim();
    if (!s) return "";
    if (/^https?:\/\//i.test(s)) return s;
    return s.startsWith("/") ? s : ("/" + s);
  };

  const prefersReducedMotion = () =>
    window.matchMedia && window.matchMedia("(prefers-reduced-motion: reduce)").matches;

  function onTap(el, fn) {
    if (!el) return;
    el.addEventListener("click", fn, { passive: true });
  }

  /* =========================================================
     1) Language Controller (CSS만 바꿈 / 레이아웃 건드리지 않음)
  ========================================================= */
  const LANG = {
    key: "LF_LANG_V4",
    mode: "korean",
    set(mode) {
      const m = (mode === "english" || mode === "hybrid") ? mode : "korean";
      this.mode = m;

      document.body.classList.remove("korean", "english", "hybrid");
      document.body.classList.add(m);

      const ko = $("#koBtn"), en = $("#enBtn"), hy = $("#hyBtn");
      [ko,en,hy].forEach(b => b && b.classList.remove("active"));
      if (m === "korean" && ko) ko.classList.add("active");
      if (m === "english" && en) en.classList.add("active");
      if (m === "hybrid" && hy) hy.classList.add("active");

      try { localStorage.setItem(this.key, m); } catch(e) {}
      BIO.syncWithGlobalLang();   // ✅ Bio도 같이 맞춤
      WORKS.rerenderCurrentPanel();
      REPORTS.render();
    },
    restore() {
      let saved = null;
      try { saved = localStorage.getItem(this.key); } catch(e) {}
      if (saved === "korean" || saved === "english" || saved === "hybrid") this.set(saved);
      else this.set("korean");
    },
    bindButtons() {
      onTap($("#koBtn"), () => this.set("korean"));
      onTap($("#enBtn"), () => this.set("english"));
      onTap($("#hyBtn"), () => this.set("hybrid"));
    }
  };

  /* =========================================================
     2) Navigation (스크롤만 / display 조작 금지)
  ========================================================= */
  const NAV = {
    btns: [],
    bind() {
      this.btns = $$('nav.primary button[data-target]');
      this.btns.forEach(b => {
        const id = (b.getAttribute("data-target") || "").trim();
        if (!id) return;
        onTap(b, () => this.go(id));
      });

      // Bio open
      onTap($("#tab-bio"), () => BIO.open());
    },
    go(id) {
      const el = document.getElementById(id);
      if (el) el.scrollIntoView({ behavior: prefersReducedMotion() ? "auto" : "smooth", block:"start" });

      // active 표시만
      this.btns.forEach(x => x.classList.remove("active"));
      const active = this.btns.find(x => (x.getAttribute("data-target")||"") === id);
      if (active) active.classList.add("active");
    }
  };

  /* =========================================================
     3) Lightbox (WORKS 배열과 1:1 고정, 확대 꼬임 방지)
  ========================================================= */
  const LIGHTBOX = {
    root: $("#lightbox"),
    img: $("#lbImg"),
    cap: $("#lbCap"),
    closeBtn: $("#lbClose"),
    isOpen: false,
    touchX: null,

    open(src, caption) {
      if (!this.root || !this.img || !src) return;

      // preload zoom for speed
      const pre = new Image();
      pre.decoding = "async";
      pre.src = src;

      this.img.src = src;
      if (this.cap) this.cap.textContent = caption || "";
      this.root.classList.add("is-open");
      this.isOpen = true;
      document.documentElement.style.overflow = "hidden";
      document.body.style.overflow = "hidden";
    },

    close() {
      if (!this.root) return;
      this.root.classList.remove("is-open");
      this.isOpen = false;
      document.documentElement.style.overflow = "";
      document.body.style.overflow = "";
    },

    bind(stepFn) {
      if (!this.root) return;

      onTap(this.closeBtn, () => this.close());

      // click outside stage: backdrop only (stage 외곽 닫기)
      this.root.addEventListener("click", (e) => {
        if (e.target === this.root) this.close();
      });

      document.addEventListener("keydown", (e) => {
        if (!this.isOpen) return;
        if (e.key === "Escape") this.close();
        if (e.key === "ArrowRight") stepFn && stepFn(+1);
        if (e.key === "ArrowLeft") stepFn && stepFn(-1);
      });

      // swipe
      this.root.addEventListener("touchstart", (e) => {
        if (!this.isOpen) return;
        this.touchX = e.touches?.[0]?.clientX ?? null;
      }, { passive:true });

      this.root.addEventListener("touchend", (e) => {
        if (!this.isOpen || this.touchX == null) return;
        const x1 = e.changedTouches?.[0]?.clientX ?? null;
        if (x1 == null) return;
        const dx = x1 - this.touchX;
        this.touchX = null;
        if (Math.abs(dx) < 42) return;
        stepFn && stepFn(dx < 0 ? +1 : -1);
      }, { passive:true });
    }
  };

  /* =========================================================
     4) Works (확대 꼬임 해결: data-id 기반 / 배열 고정)
  ========================================================= */
  const WORKS = {
    raw: [],
    bySection: {1:[],2:[],3:[],4:[],5:[]},
    currentKey: "pray",
    currentIndex: 0,

    keyToSid(key){
      return key==="pray"?1:key==="human"?2:key==="rebirth"?3:key==="exist"?4:5;
    },

    panels(){
      return {
        pray: $("#panel-pray"),
        human: $("#panel-human"),
        rebirth: $("#panel-rebirth"),
        exist: $("#panel-exist"),
        cosmos: $("#panel-cosmos")
      };
    },

    tabs(){
      return $$('button.tab[data-panel]');
    },

    async load() {
      const candidates = ["/data/works.json","data/works.json","/works.json","works.json"];
      let lastErr = null;

      for (const url of candidates) {
        try {
          const res = await fetch(url + "?" + bust(), { cache:"no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const json = await res.json();
          const arr = Array.isArray(json) ? json : (Array.isArray(json?.works) ? json.works : []);
          this.raw = arr;

          this.bySection = {1:[],2:[],3:[],4:[],5:[]};
          arr.forEach(w => {
            const sid = Number(w?.section_id);
            if (sid>=1 && sid<=5) this.bySection[sid].push(w);
          });

          return true;
        } catch(e) {
          lastErr = e;
        }
      }

      console.warn("[Works] load failed:", lastErr);
      this.raw = [];
      this.bySection = {1:[],2:[],3:[],4:[],5:[]};
      return false;
    },

    titleHTML(w) {
      const kr = safeText(w?.title_kr || "");
      const en = safeText(w?.title_en || "");
      if (LANG.mode === "english") return `<div class="en">${esc(en || kr)}</div>`;
      if (LANG.mode === "hybrid") {
        if (kr && en) return `<div class="ko">${esc(kr)}</div><div class="en">${esc(en)}</div>`;
        return `<div class="ko">${esc(kr || en)}</div>`;
      }
      return `<div class="ko">${esc(kr || en)}</div>`;
    },

    metaHTML(w) {
      const mkr = safeText(w?.material_kr || "");
      const men = safeText(w?.material_en || "");
      const skr = safeText(w?.size_kr || "");
      const sen = safeText(w?.size_en || "");
      const yr  = safeText(w?.year || "");

      const krLine = [mkr, skr, yr].filter(Boolean).join(" · ");
      const enLine = [men, sen, yr].filter(Boolean).join(" · ");

      if (LANG.mode === "english") return `<div class="en">${esc(enLine || krLine)}</div>`;
      if (LANG.mode === "hybrid") {
        if (krLine && enLine) return `<div class="ko">${esc(krLine)}</div><div class="en">${esc(enLine)}</div>`;
        return `<div class="ko">${esc(krLine || enLine)}</div>`;
      }
      return `<div class="ko">${esc(krLine || enLine)}</div>`;
    },

    imgSrc(w) { return slash(w?.image || ""); },
    zoomSrc(w) {
      const z = safeText(w?.zoom || "").trim();
      return z ? slash(z) : this.imgSrc(w);
    },

    captionText(w){
      const titlePlain =
        LANG.mode === "english" ? (w?.title_en || w?.title_kr || "")
        : (w?.title_kr || w?.title_en || "");
      const metaPlain =
        LANG.mode === "english"
          ? [w?.material_en, w?.size_en, w?.year].filter(Boolean).join(" · ")
          : [w?.material_kr, w?.size_kr, w?.year].filter(Boolean).join(" · ");
      return [titlePlain, metaPlain].filter(Boolean).join(" · ");
    },

    cardHTML(w, idx) {
      const src = this.imgSrc(w);
      if (!src) return "";

      // ✅ id/slug가 있으면 그걸 우선 사용 (확대 꼬임 방지용 key)
      const wid = safeText(w?.id || w?.work_id || w?.slug || w?.image || ("idx_"+idx));

      const alt =
        LANG.mode === "english"
          ? (w?.title_en || w?.title_kr || "")
          : (w?.title_kr || w?.title_en || "");

      return `
        <article class="w-card" data-wid="${esc(wid)}" data-idx="${idx}">
          <img class="w-thumb" loading="lazy" decoding="async" src="${esc(src)}" alt="${esc(alt)}">
          <div class="w-meta">
            <div class="w-title">${this.titleHTML(w)}</div>
            <div class="w-sub">${this.metaHTML(w)}</div>
          </div>
        </article>
      `;
    },

    currentArray() {
      const sid = this.keyToSid(this.currentKey);
      return this.bySection[sid] || [];
    },

    currentWork() {
      const arr = this.currentArray();
      if (!arr.length) return null;
      const i = clamp(this.currentIndex, 0, arr.length-1);
      return arr[i] || null;
    },

    step(delta) {
      const arr = this.currentArray();
      if (!arr.length) return null;
      const n = arr.length;
      this.currentIndex = (this.currentIndex + delta + n) % n;
      return this.currentWork();
    },

    activateTab(key){
      const tabs = this.tabs();
      tabs.forEach(b => b.classList.remove("active"));
      const active = tabs.find(b => (b.getAttribute("data-panel")||"") === key);
      if (active) active.classList.add("active");

      $$(".tabpanel").forEach(p => p.classList.remove("active"));
      const panel = this.panels()[key];
      if (panel) panel.classList.add("active");
    },

    renderPanel(key) {
      const panels = this.panels();
      const panel = panels[key] || panels.pray;
      const k = panels[key] ? key : "pray";

      this.currentKey = k;
      this.currentIndex = 0;

      this.activateTab(k);

      if (!panel) return;

      const sid = this.keyToSid(k);
      const arr = this.bySection[sid] || [];

      if (!arr.length) {
        panel.innerHTML = `<div class="w-msg">Works 데이터가 없습니다.<small>(section_id: ${sid} / /data/works.json 확인)</small></div>`;
        return;
      }

      panel.innerHTML = `<div class="w-grid">${arr.map((w,i)=>this.cardHTML(w,i)).filter(Boolean).join("")}</div>`;

      // ✅ 클릭 시: 그 카드의 idx를 그대로 currentIndex로
      $$(".w-card", panel).forEach(card => {
        onTap(card, () => {
          const idx = Number(card.getAttribute("data-idx") || "0");
          this.currentIndex = isNaN(idx) ? 0 : idx;
          const w = this.currentWork();
          if (!w) return;
          LIGHTBOX.open(this.zoomSrc(w), this.captionText(w));
        });
      });
    },

    rerenderCurrentPanel(){
      // 언어 전환 시: 같은 섹션, 같은 index 유지
      const key = this.currentKey;
      const idx = this.currentIndex;

      this.renderPanel(key);
      const arr = this.currentArray();
      if (arr.length) this.currentIndex = clamp(idx, 0, arr.length-1);
    },

    bindTabs() {
      this.tabs().forEach(btn => {
        const k = (btn.getAttribute("data-panel") || "").trim();
        if (!k) return;
        onTap(btn, () => this.renderPanel(k));
      });
    },

    async init() {
      this.bindTabs();
      await this.load();

      const active = this.tabs().find(b => b.classList.contains("active"));
      const key = active ? (active.getAttribute("data-panel") || "pray") : "pray";
      this.renderPanel(key);
    }
  };

  /* =========================================================
     5) Reports (KR/EN/KR+EN 분리 렌더 + 새 창 viewer + download)
  ========================================================= */
  const REPORTS = {
    list: [],
    grid: $("#reportGrid"),
    toggleBtn: $("#reportsToggle"),
    tabBtns: $$('button.r-tab[data-r]'),
    filter: "all",
    opened: false,

    async load() {
      const candidates = ["/data/reports.json","data/reports.json","/reports.json","reports.json"];
      let lastErr = null;

      for (const url of candidates) {
        try {
          const res = await fetch(url + "?" + bust(), { cache:"no-store" });
          if (!res.ok) throw new Error("HTTP " + res.status);
          const json = await res.json();
          const arr = Array.isArray(json) ? json : (Array.isArray(json?.reports) ? json.reports : []);
          this.list = arr;
          return true;
        } catch(e) {
          lastErr = e;
        }
      }

      console.warn("[Reports] load failed:", lastErr);
      this.list = [];
      return false;
    },

    titleHTML(r) {
      const kr = safeText(r?.title_ko || "");
      const en = safeText(r?.title_en || "");
      if (LANG.mode === "english") return `<span class="en">${esc(en || kr)}</span>`;
      if (LANG.mode === "hybrid") {
        if (kr && en) return `<span class="ko">${esc(kr)}</span><br><span class="en">${esc(en)}</span>`;
        return `<span class="ko">${esc(kr || en)}</span>`;
      }
      return `<span class="ko">${esc(kr || en)}</span>`;
    },

    summaryHTML(r) {
      const kr = safeText(r?.summary_ko || "");
      const en = safeText(r?.summary_en || "");
      if (LANG.mode === "english") return `<span class="en">${esc(en || kr)}</span>`;
      if (LANG.mode === "hybrid") {
        if (kr && en) return `<span class="ko">${esc(kr)}</span><br><span class="en">${esc(en)}</span>`;
        return `<span class="ko">${esc(kr || en)}</span>`;
      }
      return `<span class="ko">${esc(kr || en)}</span>`;
    },

    mdURL(r) { return slash(r?.md_path || ""); },

    matchFilter(r){
      if (this.filter === "all") return true;
      const cat = safeText(r?.category || r?.type || "").toLowerCase();
      return cat === this.filter;
    },

    cardHTML(r) {
      const id = safeText(r?.id || r?.slug || "");
      const url = this.mdURL(r);
      return `
        <article class="r-item" data-md="${esc(url)}" data-id="${esc(id)}">
          <div class="t">${this.titleHTML(r)}</div>
          <div class="m">${esc(id)}</div>
          <div class="s">${this.summaryHTML(r)}</div>
        </article>
      `;
    },

    setOpen(open){
      this.opened = !!open;
      if (!this.grid || !this.toggleBtn) return;

      this.grid.classList.toggle("is-open", this.opened);
      this.toggleBtn.setAttribute("aria-expanded", this.opened ? "true" : "false");
      this.toggleBtn.textContent = this.opened ? "Close Reports" : "Open Reports";
    },

    setFilter(f){
      this.filter = (f === "theory" || f === "archive" || f === "practice") ? f : "all";
      this.tabBtns.forEach(b => b.classList.remove("is-active"));
      const active = this.tabBtns.find(b => (b.getAttribute("data-r") || "") === this.filter);
      if (active) active.classList.add("is-active");
      this.render();
    },

    async openViewerWindow({ id, title, mdURL }) {
      const w = window.open("", "_blank", "noopener,noreferrer");
      if (!w) {
        if (mdURL) window.open(mdURL, "_blank", "noopener,noreferrer");
        return;
      }

      const docTitle = title || id || "Report";
      const shell = `
<!doctype html>
<html lang="ko">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover">
  <title>${esc(docTitle)}</title>
  <style>
    :root{ --bg:#070A14; --fg:#eef3ff; --muted:#aab7dd; --gold:#e6c777; }
    *{box-sizing:border-box;margin:0;padding:0}
    body{
      background: radial-gradient(1200px 600px at 50% -10%, rgba(170,205,255,.10), transparent 60%),
                  linear-gradient(180deg, #070A14, #02030a);
      color:var(--fg);
      font: 15px/1.85 system-ui,-apple-system,Segoe UI,Roboto,"Noto Sans KR",sans-serif;
    }
    header{
      position:sticky;top:0;z-index:20;
      padding:14px 16px;
      background: linear-gradient(180deg, rgba(8,12,24,.96), rgba(8,12,24,.80));
      border-bottom:1px solid rgba(255,255,255,.08);
      backdrop-filter: blur(10px);
      text-align:center;
    }
    h1{font-size:18px;color:var(--gold);letter-spacing:.04em}
    .meta{margin-top:6px;font-size:12px;color:var(--muted);font-family: ui-monospace,Menlo,Consolas,monospace;}
    main{max-width:980px;margin:0 auto;padding:18px 16px 44px}
    pre{
      white-space:pre-wrap;
      overflow-wrap:anywhere;
      background: linear-gradient(180deg, rgba(11,18,44,.92), rgba(5,8,20,.86));
      border:1px solid rgba(230,199,119,.18);
      border-radius:14px;
      padding:16px 14px 18px;
    }
    .bar{margin-top:14px;display:flex;justify-content:center;gap:10px;flex-wrap:wrap}
    a{
      color:var(--gold);
      text-decoration:none;
      border:1px solid rgba(230,199,119,.35);
      padding:6px 10px;border-radius:999px;font-size:12px;
    }
    a:hover{background:rgba(230,199,119,.12)}
    .tiny{margin-top:12px;font-size:12px;color:rgba(255,255,255,.65);text-align:center}
  </style>
</head>
<body>
  <header>
    <h1>${esc(docTitle)}</h1>
    <div class="meta">${esc(id)}</div>
  </header>
  <main>
    <pre id="content">Loading…</pre>
    <div class="bar" id="bar"></div>
    <div class="tiny">Lightflow · Reports Viewer</div>
  </main>
</body>
</html>`.trim();

      w.document.open();
      w.document.write(shell);
      w.document.close();

      const contentEl = w.document.getElementById("content");
      const barEl = w.document.getElementById("bar");

      if (barEl && mdURL) {
        barEl.innerHTML = `<a href="${esc(mdURL)}" target="_blank" rel="noopener">download</a>`;
      }

      if (!mdURL) {
        if (contentEl) contentEl.textContent = "No md_path found in reports.json.";
        return;
      }

      try {
        const res = await fetch(mdURL + "?" + bust(), { cache:"no-store" });
        if (!res.ok) throw new Error("HTTP " + res.status);
        const text = await res.text();
        if (contentEl) contentEl.textContent = text.trim();
      } catch(e) {
        if (contentEl) contentEl.textContent =
          "Failed to load report text.\n\nOpen the download link instead.\n\n" + String(e);
      }
    },

    render() {
      if (!this.grid) this.grid = $("#reportGrid");
      if (!this.grid) return;

      const filtered = this.list.filter(r => this.matchFilter(r));
      if (!filtered.length) {
        this.grid.innerHTML = `<div class="w-msg">Reports 데이터가 없습니다.<small>(/data/reports.json 확인)</small></div>`;
        return;
      }

      this.grid.innerHTML = filtered.map(r => this.cardHTML(r)).join("");

      $$(".r-item", this.grid).forEach(card => {
        onTap(card, () => {
          const md = card.getAttribute("data-md") || "";
          const id = card.getAttribute("data-id") || "REPORT";
          const titleText = (card.querySelector(".t")?.textContent || id).trim();
          this.openViewerWindow({ id, title:titleText, mdURL: md });
        });
      });
    },

    bind(){
      this.toggleBtn = $("#reportsToggle");
      this.grid = $("#reportGrid");
      this.tabBtns = $$('button.r-tab[data-r]');

      if (this.toggleBtn) onTap(this.toggleBtn, () => this.setOpen(!this.opened));
      this.tabBtns.forEach(btn => {
        const f = (btn.getAttribute("data-r") || "all").trim();
        onTap(btn, () => this.setFilter(f));
      });
    },

    async init() {
      this.bind();
      await this.load();
      this.setFilter("all");
      this.setOpen(false);
    }
  };

  /* =========================================================
     6) Bio (modal + expo slide + 글로벌 언어 동기화)
  ========================================================= */
  const BIO = {
    modal: $("#bio-modal"),
    openBtn: $("#tab-bio"),
    closeBtn: $(".bio-close"),
    backdrop: $(".bio-backdrop"),
    expoBtn: $("#expoToggle"),
    expoSlide: $("#expoSlide"),
    bioLangBtns: $$('#bio-modal .bio-lang .lang[data-bio-lang]'),

    open() { if (this.modal) this.modal.hidden = false; },
    close() { if (this.modal) this.modal.hidden = true; },

    setBioLang(mode){ // "kr" | "en"
      const m = (mode === "en") ? "en" : "kr";
      const koBodies = $$('#bio-modal .bio-body.ko');
      const enBodies = $$('#bio-modal .bio-body.en');

      // ✅ Bio 모달 내부 언어는 “둘 중 하나만” 노출
      koBodies.forEach(el => el.style.display = (m === "kr") ? "" : "none");
      enBodies.forEach(el => el.style.display = (m === "en") ? "" : "none");

      this.bioLangBtns.forEach(b => b.classList.remove("active"));
      const active = this.bioLangBtns.find(b => (b.getAttribute("data-bio-lang")||"") === m);
      if (active) active.classList.add("active");
    },

    syncWithGlobalLang(){
      // ✅ 글로벌 언어가 EN이면 Bio도 EN, 그 외는 KR
      if (LANG.mode === "english") this.setBioLang("en");
      else this.setBioLang("kr");
    },

    toggleExpo() {
      if (!this.expoSlide || !this.expoBtn) return;
      const open = this.expoSlide.getAttribute("data-open") === "true";
      this.expoSlide.setAttribute("data-open", open ? "false" : "true");
      this.expoBtn.setAttribute("aria-expanded", open ? "false" : "true");
    },

    bind() {
      if (this.openBtn) onTap(this.openBtn, () => this.open());
      if (this.closeBtn) onTap(this.closeBtn, () => this.close());
      if (this.backdrop) onTap(this.backdrop, () => this.close());
      if (this.expoBtn) onTap(this.expoBtn, () => this.toggleExpo());

      this.bioLangBtns.forEach(btn => {
        const m = (btn.getAttribute("data-bio-lang")||"kr").trim();
        onTap(btn, () => this.setBioLang(m));
      });

      document.addEventListener("keydown", (e) => {
        if (!this.modal || this.modal.hidden) return;
        if (e.key === "Escape") this.close();
      });

      // init state
      this.syncWithGlobalLang();
    }
  };

  /* =========================================================
     7) Sound (공명형 우주음: WebAudio 생성 / 외부파일 불필요)
  ========================================================= */
  const SOUND = {
    ctx: null,
    master: null,
    analyser: null,
    fftEl: $("#fftBar span"),
    playing: false,
    raf: 0,

    start(){
      if (this.playing) return;

      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      if (!AudioCtx) return;

      if (!this.ctx) this.ctx = new AudioCtx();

      // iOS: resume 필요
      if (this.ctx.state === "suspended") this.ctx.resume();

      // graph
      const ctx = this.ctx;
      this.master = ctx.createGain();
      this.master.gain.value = 0.0;

      this.analyser = ctx.createAnalyser();
      this.analyser.fftSize = 512;

      // gentle drone (3 osc + filter)
      const o1 = ctx.createOscillator();
      const o2 = ctx.createOscillator();
      const o3 = ctx.createOscillator();
      o1.type = "sine";
      o2.type = "sine";
      o3.type = "triangle";

      // base freq (명상적 공명)
      o1.frequency.value = 55.0;     // A1
      o2.frequency.value = 110.0;    // A2
      o3.frequency.value = 82.41;    // E2

      const g1 = ctx.createGain(); g1.gain.value = 0.10;
      const g2 = ctx.createGain(); g2.gain.value = 0.06;
      const g3 = ctx.createGain(); g3.gain.value = 0.05;

      const filt = ctx.createBiquadFilter();
      filt.type = "lowpass";
      filt.frequency.value = 1200;
      filt.Q.value = 0.7;

      // slow movement (LFO)
      const lfo = ctx.createOscillator();
      lfo.type = "sine";
      lfo.frequency.value = 0.06;
      const lfoGain = ctx.createGain();
      lfoGain.gain.value = 240; // filter sweep
      lfo.connect(lfoGain);
      lfoGain.connect(filt.frequency);

      // master fade in
      const now = ctx.currentTime;
      this.master.gain.cancelScheduledValues(now);
      this.master.gain.setValueAtTime(0.0, now);
      this.master.gain.linearRampToValueAtTime(0.38, now + 1.2);

      // connect
      o1.connect(g1); o2.connect(g2); o3.connect(g3);
      g1.connect(filt); g2.connect(filt); g3.connect(filt);
      filt.connect(this.analyser);
      this.analyser.connect(this.master);
      this.master.connect(ctx.destination);

      // store nodes for stop
      this._nodes = { o1,o2,o3,g1,g2,g3,filt,lfo,lfoGain };

      // start
      o1.start(); o2.start(); o3.start();
      lfo.start();

      this.playing = true;
      this._fftLoop();

      // UI
      const playBtn = $("#soundBtn");
      const stopBtn = $("#soundStopBtn");
      if (playBtn) playBtn.disabled = true;
      if (stopBtn) stopBtn.disabled = false;
    },

    stop(){
      if (!this.playing || !this.ctx) return;

      const ctx = this.ctx;
      const now = ctx.currentTime;

      try{
        this.master.gain.cancelScheduledValues(now);
        this.master.gain.setValueAtTime(this.master.gain.value, now);
        this.master.gain.linearRampToValueAtTime(0.0, now + 0.5);
      }catch(e){}

      window.setTimeout(() => {
        try{
          const n = this._nodes;
          if (n){
            n.o1.stop(); n.o2.stop(); n.o3.stop();
            n.lfo.stop();
          }
        }catch(e){}
        this._nodes = null;
      }, 520);

      this.playing = false;
      cancelAnimationFrame(this.raf);
      this.raf = 0;

      if (this.fftEl) this.fftEl.style.width = "0%";

      // UI
      const playBtn = $("#soundBtn");
      const stopBtn = $("#soundStopBtn");
      if (playBtn) playBtn.disabled = false;
      if (stopBtn) stopBtn.disabled = true;
    },

    _fftLoop(){
      if (!this.analyser || !this.fftEl || !this.playing) return;

      const arr = new Uint8Array(this.analyser.frequencyBinCount);
      this.analyser.getByteFrequencyData(arr);

      // average energy
      let sum = 0;
      for (let i=0;i<arr.length;i++) sum += arr[i];
      const avg = sum / arr.length; // 0..255

      const pct = clamp((avg / 255) * 100 * 1.25, 0, 100);
      this.fftEl.style.width = pct.toFixed(1) + "%";

      this.raf = requestAnimationFrame(() => this._fftLoop());
    },

    bind(){
      onTap($("#soundBtn"), () => this.start());
      onTap($("#soundStopBtn"), () => this.stop());
    }
  };

  /* =========================================================
     8) Waves (가벼운 파동 + reduced-motion 대응)
  ========================================================= */
  const WAVES = {
    c: $("#waves"),
    ctx: null,
    w: 0,
    h: 0,
    t: 0,
    raf: 0,
    resize(){
      if (!this.c) return;
      const dpr = Math.min(2, window.devicePixelRatio || 1);
      this.w = Math.floor(window.innerWidth * dpr);
      this.h = Math.floor(window.innerHeight * dpr);
      this.c.width = this.w;
      this.c.height = this.h;
      this.c.style.width = "100%";
      this.c.style.height = "100%";
      this.ctx = this.c.getContext("2d", { alpha:true });
      if (this.ctx) this.ctx.setTransform(1,0,0,1,0,0);
      this.dpr = dpr;
    },
    draw(){
      if (!this.ctx) return;
      const ctx = this.ctx;

      ctx.clearRect(0,0,this.w,this.h);

      // subtle waves
      const t = this.t;
      const midY = this.h * 0.52;
      const amp = this.h * 0.015;

      ctx.globalAlpha = 0.55;

      // gold wave
      ctx.beginPath();
      for (let x=0; x<=this.w; x+=14*this.dpr){
        const y = midY + Math.sin((x*0.0038) + t*0.9) * amp
                        + Math.sin((x*0.0018) - t*0.6) * (amp*0.7);
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = "rgba(215,184,106,0.16)";
      ctx.lineWidth = 2*this.dpr;
      ctx.stroke();

      // blue wave
      ctx.beginPath();
      for (let x=0; x<=this.w; x+=16*this.dpr){
        const y = (midY - this.h*0.10) + Math.sin((x*0.0032) - t*0.8) * (amp*0.9)
                                   + Math.sin((x*0.0014) + t*0.5) * (amp*0.5);
        if (x===0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      }
      ctx.strokeStyle = "rgba(121,167,255,0.12)";
      ctx.lineWidth = 2*this.dpr;
      ctx.stroke();

      ctx.globalAlpha = 1;
    },
    loop(){
      if (prefersReducedMotion()) return; // reduced-motion: 정지
      this.t += 0.016;
      this.draw();
      this.raf = requestAnimationFrame(() => this.loop());
    },
    init(){
      this.resize();
      window.addEventListener("resize", () => this.resize(), { passive:true });
      this.loop();
    }
  };

  /* =========================================================
     9) Init
  ========================================================= */
  async function init(){
    LANG.restore();
    LANG.bindButtons();

    NAV.bind();

    // Works / Reports
    await WORKS.init();
    await REPORTS.init();

    // Lightbox step
    LIGHTBOX.bind((delta) => {
      const w = WORKS.step(delta);
      if (!w) return;
      LIGHTBOX.open(WORKS.zoomSrc(w), WORKS.captionText(w));
    });

    // Bio / Sound / Waves
    BIO.bind();
    SOUND.bind();
    WAVES.init();
  }

  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", init, { once:true });
  } else {
    init();
  }
})();
</script>

</body>
</html>